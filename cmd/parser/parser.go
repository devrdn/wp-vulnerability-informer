package main

import (
	"database/sql"
	"github.com/devrdn/wp-vulnerability-parser/internal/models"
	"github.com/gocolly/colly/v2"
	"log"
	"regexp"
	"strconv"
	"time"
)

const (
	Url = "https://www.wordfence.com/threat-intel/vulnerabilities"

	VulnerabilityPageWrapperEl = "div#app-wrapper"
	VulnerabilitySingleEl      = ".threat-intel-vulns-table tbody tr"
	VulnerabilityNameEl        = "div.container h1.text-center"
	VulnerabilityDescEl        = "div.card-body h3 + p"
	VulnerabilityLinkEl        = "td:first-child a"
	VulnerabilitySeverityEl    = "div.card-body .cvss-score-chart span"
	VulnerabilityDateEl        = "div.card-body table.table-sm tbody tr:nth-child(3) td.text-right"
	VulnerabilityVersionEl     = "section.mb-5 div.card-body table.table.no-first-row-border tr:nth-child(5) td"
	VulnerabilityTypeEl        = "section.mb-5 div.card-body table.table.no-first-row-border tr:nth-child(1) td"
	VulnerabilitySlugEl        = "section.mb-5 div.card-body table.table.no-first-row-border tr:nth-child(2) td"

	FromPage = 1
	ToPage   = 1
)

type Parser struct {
	db *sql.DB
}

func NewParser(db *sql.DB) Parser {
	return Parser{
		db: db,
	}
}

// The Parse method parses the page with WordPress vulnerabilities
// from public database and return array of vulnerabilities
func (p *Parser) Parse() ([]*models.Vulnerability, error) {
	c := colly.NewCollector()

	_ = c.Limit(&colly.LimitRule{Delay: 2 * time.Second})

	var vulnerabilities []*models.Vulnerability

	c.OnHTML(VulnerabilityPageWrapperEl, func(h *colly.HTMLElement) {
		vulnerability := &models.Vulnerability{}

		// main info parse
		vulnerability.Slug = p.GetSanitizedSlug(h.ChildText(VulnerabilitySlugEl))
		vulnerability.Link = h.Request.URL.String()
		vulnerability.Description = h.ChildText(VulnerabilityDescEl)
		vulnerability.Name = h.ChildText(VulnerabilityNameEl)
		vulnerability.Version = h.ChildText(VulnerabilityVersionEl)
		vulnerability.Type = h.ChildText(VulnerabilityTypeEl)

		// severity parse
		severity, err := strconv.ParseFloat(h.ChildText(VulnerabilitySeverityEl), 32)
		if err != nil {
			log.Println(err)
			return
		}
		vulnerability.Severity = float32(severity)

		// date parse
		date, err := time.Parse("January 2, 2006", h.ChildText(VulnerabilityDateEl))
		if err != nil {
			log.Println(err)
			return
		}
		vulnerability.Date = date

		vulnerabilities = append(vulnerabilities, vulnerability)
	})

	// visit every vulnerability page
	c.OnHTML(VulnerabilitySingleEl, func(h *colly.HTMLElement) {
		err := h.Request.Visit(h.ChildAttr(VulnerabilityLinkEl, "href"))
		if err != nil {
			log.Println(err)
			return
		}
	})

	for i := FromPage; i <= ToPage; i++ {
		err := c.Visit(Url + "/?page=" + strconv.Itoa(i))
		if err != nil {
			return nil, err
		}
	}

	c.Wait()

	return vulnerabilities, nil
}

// GetSanitizedSlug method takes "dirty" slug name
// and returns without unnecessary postfix
//
// e.g. <slug>(view on wordpress.org) -> <slug>
func (p *Parser) GetSanitizedSlug(slug string) string {
	regex, err := regexp.Compile(`^(.*)\s+\(view on wordpress\.org\)$`)
	if err != nil {
		return ""
	}

	sanitizedSlug := regex.FindStringSubmatch(slug)

	if len(sanitizedSlug) > 0 {
		return sanitizedSlug[1]
	}
	return slug
}
