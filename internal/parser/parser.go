package parser

import (
	"fmt"
	"html"
	"log"
	"strings"
	"time"

	"github.com/devrdn/wp-vulnerability-informer/internal/models"
	"github.com/gocolly/colly/v2"
)

const (
	ElVulnPageWrapper = "div#app-wrapper"
	ElVulnSingle      = ".threat-intel-vulns-table tbody tr"
	ElVulnName        = "div.container h1.text-center"
	ElVulnDesc        = "div.card-body h3 + p"
	ElVulnLink        = "td:first-child a"
	ElVulnSeverity    = "div.card-body .cvss-score-chart span"
	ElVulnDate        = "div.card-body table.table-sm tbody tr:nth-child(3) td.text-right"
	ElVulnVersion     = "section.mb-5 .col-12:first-child div.card-body table.table.no-first-row-border tr:nth-child(5) td"
	ElVulnType        = "section.mb-5 .col-12:first-child div.card-body table.table.no-first-row-border tr:nth-child(1) td"
)

type Parser struct {
	url   string
	limit int
	c     *colly.Collector
}

func New(limit int, url string) *Parser {
	return &Parser{
		url:   url,
		limit: limit,
		c:     colly.NewCollector(),
	}
}

// The Parse method parses the page with WordPress vulnerabilities
// from public database and return array of vulnerabilities
func (p *Parser) Parse() ([]models.Vulnerability, error) {
	vulnerabilities := make([]models.Vulnerability, 0, p.limit*20)

	p.c.OnHTML(ElVulnPageWrapper, func(h *colly.HTMLElement) {
		// check if page is single vulnerability page
		if strings.HasPrefix(h.Request.URL.String(), p.url) {
			return
		}

		// get slug
		slug := strings.Split(h.Request.URL.String(), "/")

		// date parse
		date, err := time.Parse("January 2, 2006", h.ChildText(ElVulnDate))
		if err != nil {
			log.Println(err)
			return
		}

		vulnerability := models.Vulnerability{
			Slug:        slug[len(slug)-1],
			Link:        h.Request.URL.String(),
			Description: html.EscapeString(h.ChildText(ElVulnDesc)),
			Name:        html.EscapeString(h.ChildText(ElVulnName)),
			Version:     html.EscapeString(h.ChildText(ElVulnVersion)),
			Type:        h.ChildText(ElVulnType),
			Severity:    h.ChildText(ElVulnSeverity),
			Date:        date,
		}

		vulnerabilities = append(vulnerabilities, vulnerability)
	})

	// visit every vulnerability page
	p.c.OnHTML(ElVulnSingle, func(h *colly.HTMLElement) {
		err := h.Request.Visit(h.ChildAttr(ElVulnLink, "href"))
		if err != nil {
			log.Println(err)
			return
		}
	})

	p.c.OnError(func(r *colly.Response, err error) {
		log.Printf("parser: error on page: `%s`: %s", r.Request.URL, err)
	})

	for i := 1; i <= p.limit; i++ {
		err := p.c.Visit(fmt.Sprint(p.url, i))
		if err != nil {
			return nil, err
		}
	}

	return vulnerabilities, nil
}
