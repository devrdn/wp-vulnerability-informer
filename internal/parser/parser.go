package parser

import (
	"github.com/gocolly/colly/v2"
	"log"
	"strconv"
	"time"
)

type Parser struct {
	url         string
	c           *colly.Collector
	parsePolicy ParsePolicy
}

type ParsePolicy interface {
	isAcceptable(vulnerability *Vulnerability) bool
}

type DefaultParsePolicy struct {
}

func (dp *DefaultParsePolicy) isAcceptable(_ *Vulnerability) bool {
	return true
}

func NewParser(url string, c *colly.Collector, pp ParsePolicy) *Parser {

	if pp == nil {
		pp = &DefaultParsePolicy{}
	}

	return &Parser{
		url:         url,
		c:           c,
		parsePolicy: pp,
	}
}

// The Parse method parses the page with WordPress vulnerabilities
// and returns only those vulnerabilities
// that fall under the specified policy.
//
// For example, vulnerabilities that appeared on September 5th.
func (p *Parser) Parse() ([]*Vulnerability, error) {

	var vulnerabilities []*Vulnerability

	// parse html page
	p.c.OnHTML(".threat-intel-vulns-table tbody tr", func(h *colly.HTMLElement) {
		vulnerability := &Vulnerability{}
		vulnerability.Name = h.ChildText("td:first-child")

		severity, err := strconv.ParseFloat(h.ChildText(".cvss-badge-column"), 32)
		if err != nil {
			log.Fatal(err)
			return
		}

		vulnerability.Severity = float32(severity)

		date, err := time.Parse("January 2, 2006", h.ChildText(".date-column"))
		if err != nil {
			log.Fatal(err)
			return
		}

		vulnerability.Date = date

		if p.parsePolicy.isAcceptable(vulnerability) {
			vulnerabilities = append(vulnerabilities, vulnerability)
		}
	})

	err := p.c.Visit(p.url)
	if err != nil {
		return nil, err
	}

	p.c.Wait()

	return vulnerabilities, nil
}
